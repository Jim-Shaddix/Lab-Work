<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of TDMS_retrievingSubsets</title>
  <meta name="keywords" content="TDMS_retrievingSubsets">
  <meta name="description" content="TDMS_retrievingSubsets  Documentation for retrieving subsets of raw data from TDMS_readTDMSFile">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../../menu.html tdms_peak_analysis --><!-- ../../menu.html Store_TDMS_Data --><!-- ../menu.html Matlab_readTDMS_package --><!-- menu.html tdmsSubfunctions -->
<h1>TDMS_retrievingSubsets
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>TDMS_retrievingSubsets  Documentation for retrieving subsets of raw data from TDMS_readTDMSFile</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function TDMS_retrievingSubsets </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">TDMS_retrievingSubsets  Documentation for retrieving subsets of raw data from TDMS_readTDMSFile

   I created this file as a place to document retrieval of subsets of
   data, instead of making the documentation in the main function rather
   long.  All property/value pairs would still get passed into the
   TDMS_readTDMSfile.

   NOTE: FOR MULTIPLE CALLS TO THE SAME FILE
   It is recommended that you pass the meta_struct from an initial read
   back into the function.  See examples below.

   There are currently 3 methods for filtering data:

   PROPERTY NOTES:
   *  indicates input dependence, may be required, depends on input
   ** indicates an applicable but always optional property
   All properties are defined 

   1) OBJECT INCLUSION, EXCLUSION, NO RAW DATA
   =======================================================================
   Specificy which channels to retrieve or not to retrieve, or whether
   or not to just get properties and no raw data.  This is implemented via
   the GET_DATA_OPTION property, in conjunction with OBJECTS_GET and
   OBJECTS_IGNORE.  In this case, if raw data is retrieved, then all of
   the raw data available for each non-ignored object is retrieved.

   PROPERTIES: (defined in separate section)
       - GET_DATA_OPTION
       - * OBJECTS_GET
       - * OBJECTS_IGNORE
       - ** META_STRUCT

   EXAMPLE:
   a) [~,metaStruct] = TDMS_readTDMSfile(fileName,'GET_DATA_OPTION','getnone')

      %some code ...
      objStruct = struct;
      objStruct.groupsKeep = {'myGroup1' 'myGroup2'};
   
      data = TDMS_readTDMSfile(fileName,'META_STRUCT',metaStruct,...
               'GET_DATA_OPTION','getSubset','OBJECTS_GET',objStruct);


   2) SINGLE SUBSET OF RAW DATA, FOR ALL NON-IGNORED OBJECTS
   =======================================================================
   This method was designed as an extension to the specification above.
   Use of the SUBSET_GET property, allows additional filtering for those
   channels that are not excluded.  The same amount of data is read from
   each channel, and only one subset can be specified. 
   
   PROPERTIES: 
       - SUBSET_GET
       - ** GET_DATA_OPTION
       - * OBJECTS_GET
       - * OBJECTS_IGNORE
       - ** META_STRUCT
       - ** SUBSET_IS_LENGTH
       
   EXAMPLES:
   a) [~,metaStruct] = TDMS_readTDMSfile(fileName,'GET_DATA_OPTION','getnone')

   %some code ...
   
   data = TDMS_readTDMSfile(metaStruct,'SUBSET_GET',[100 2000],...
                       'SUBSET_IS_LENGTH',true)

   This reads the same amount of data from all objects with data.  The
   GET_DATA_OPTION has not been used to limit which objects to retrieve.
   The SUBSET_IS_LENGTH = true (defined below), indicates that the 2000
   value indicates the # of samples to read, not the stopping index.

   3) COMPLETE SPECIFICATION OF DATA TO RETRIEVE
   =======================================================================
   This was designed to offer even more flexibility.  In this case the
   GET_DATA_OPTION and SUBSET_GET are IGNORED.  A new variable,
   GET_INDICES needs to be specified.

   PROPERTIES:
       - GET_INDICES
       - ** META_STRUCT
       - ** SUBSET_IS_LENGTH

   EXAMPLES:
   a) [~,metaStruct] = TDMS_readTDMSfile(fileName,'GET_DATA_OPTION','getnone')

   %some code
   
   getStruct = struct('group',myGroup,'channel',myChannel,...
       indices,[1 5; 10 5; 20 5; 30 5]);

   data = TDMS_readTDMSfile(metaStruct,'GET_INDICES',getStruct);

   SIDENOTE ON IMAGES:
   Since tdms does not support 2d writing, image data itself can be 
   represented in 1d with multiple lines.  Reading multiple contiguous 
   frames of image data would only require a single read.  If however, for
   each of those images, a subset of that frame is needed, then data is
   needed in a non-contiguous fashion. This may be acheivable via 
   indexing in Matlab.  When memory is a concern, this might be better to
   do when originally reading in the data. This was the original motivation
   for developing this read specification.

   =======================================================================
                         PROPERTIES - DEFINITIONS
   =======================================================================
   NOTE: These values get passed in as property/value pairs into the 
   TDMS_readTDMSfile

   GET_DATA_OPTION = (default 'getAll')
                       NOTE: This applies specifically to the channels and
                       groups, not to the data that is in those objects
               'getall'       - retrieve raw data from all objects
               'getnone'      - retrieve raw data from no objects
               'ignoreSubset' - requires population of OBJECTS_IGNORE
                                retrieves raw data for all objects except
                                those specified
               'getSubset'    - requires population of OBJECTS_GET
                                retrieves raw data only from objects
                                specified

   OBJECTS_GET     = must be specified for GET_DATA_OPTION = 'getSubset'
               (structure) with fields:
               .fullPathsKeep - (cell array of strings) the full object
                                path name like /'myGroup'/'myChan' (NOTE:
                                the apostrophes are needed)
               .groupsKeep    - (cell array of strings) the name of any
                                 groups to keep -&gt; 'myGroup', all channels
                                 in that group are retrieved
   OBJECTS_IGNORE  = must be specified for GET_DATA_OPTION = 'ignoreSubset'
               (structure with fields:
               .fullPathsIgnore - (see above), specified paths don't
                                  retrieve raw data
               .groupsIgnore    - (see above), raw data not retrieved for 
                                  any of the channels in the groups mentioned

   SUBSET_GET     = (2 column array), cols =&gt;
                    [start sample, # of samples] 
                               or 
                    [start sample, stop sample] 
                               for SUBSET_IS_LENGTH = false
                    The default, [], indicates to retrieve all raw data 
                    for an object.  WARNING: Only implemented for
                    decimated data, not interleaved

   SUBSET_IS_LENGTH = (default true), if true, then the 2nd input for
                       SUBSET_GET, and the 2nd column for the 'indices'
                       field in GET_INDICES, is treated as the # of
                       samples to read, if false, it is treated as the
                       stopping index

   GET_INDICES     = (structure array), length is equal to the number
                      of channels to retrieve
               .group   - group name of object to retrieve
               .channel - channel name of object to retrieve
               .indices - (rows by 2 columns), first column indicates the 
                          the first sample to retreive (1 based), 2nd
                          columns indicates either the # of samples to
                          retrieve (SUBSET_IS_LENGTH = true) or the last
                          sample to grab (SUBSET_IS_LENGTH = false)
                          WARNINGS: 
                            - Only implemented for decimated data
                            - indices must be sorted and non-overlapping
                            i.e. for SUBSET_IS_LENGTH = false,
                               .indices = [5 10; 15 20] is fine
                               .indices = [5 10; 10 20] fine ...
                               NOTE: 10 will only be returned once
                               .indices = [5 10; 8 15] not ok, (overlapping)
                               .indices = [15 20; 5 10] not ok, (not sorted)
   
   META_STRUCT     = The meta struct from a previous parsing. Passing this
                     in when reading the same file that generated the meta
                     struct previously can significantly speed up
                     processing time.


   See Also:
       TDMS_readTDMSFile</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function TDMS_retrievingSubsets</a>
0002 <span class="comment">%TDMS_retrievingSubsets  Documentation for retrieving subsets of raw data from TDMS_readTDMSFile</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   I created this file as a place to document retrieval of subsets of</span>
0005 <span class="comment">%   data, instead of making the documentation in the main function rather</span>
0006 <span class="comment">%   long.  All property/value pairs would still get passed into the</span>
0007 <span class="comment">%   TDMS_readTDMSfile.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   NOTE: FOR MULTIPLE CALLS TO THE SAME FILE</span>
0010 <span class="comment">%   It is recommended that you pass the meta_struct from an initial read</span>
0011 <span class="comment">%   back into the function.  See examples below.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">%   There are currently 3 methods for filtering data:</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%   PROPERTY NOTES:</span>
0016 <span class="comment">%   *  indicates input dependence, may be required, depends on input</span>
0017 <span class="comment">%   ** indicates an applicable but always optional property</span>
0018 <span class="comment">%   All properties are defined</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%   1) OBJECT INCLUSION, EXCLUSION, NO RAW DATA</span>
0021 <span class="comment">%   =======================================================================</span>
0022 <span class="comment">%   Specificy which channels to retrieve or not to retrieve, or whether</span>
0023 <span class="comment">%   or not to just get properties and no raw data.  This is implemented via</span>
0024 <span class="comment">%   the GET_DATA_OPTION property, in conjunction with OBJECTS_GET and</span>
0025 <span class="comment">%   OBJECTS_IGNORE.  In this case, if raw data is retrieved, then all of</span>
0026 <span class="comment">%   the raw data available for each non-ignored object is retrieved.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%   PROPERTIES: (defined in separate section)</span>
0029 <span class="comment">%       - GET_DATA_OPTION</span>
0030 <span class="comment">%       - * OBJECTS_GET</span>
0031 <span class="comment">%       - * OBJECTS_IGNORE</span>
0032 <span class="comment">%       - ** META_STRUCT</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%   EXAMPLE:</span>
0035 <span class="comment">%   a) [~,metaStruct] = TDMS_readTDMSfile(fileName,'GET_DATA_OPTION','getnone')</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%      %some code ...</span>
0038 <span class="comment">%      objStruct = struct;</span>
0039 <span class="comment">%      objStruct.groupsKeep = {'myGroup1' 'myGroup2'};</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%      data = TDMS_readTDMSfile(fileName,'META_STRUCT',metaStruct,...</span>
0042 <span class="comment">%               'GET_DATA_OPTION','getSubset','OBJECTS_GET',objStruct);</span>
0043 <span class="comment">%</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%   2) SINGLE SUBSET OF RAW DATA, FOR ALL NON-IGNORED OBJECTS</span>
0046 <span class="comment">%   =======================================================================</span>
0047 <span class="comment">%   This method was designed as an extension to the specification above.</span>
0048 <span class="comment">%   Use of the SUBSET_GET property, allows additional filtering for those</span>
0049 <span class="comment">%   channels that are not excluded.  The same amount of data is read from</span>
0050 <span class="comment">%   each channel, and only one subset can be specified.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">%   PROPERTIES:</span>
0053 <span class="comment">%       - SUBSET_GET</span>
0054 <span class="comment">%       - ** GET_DATA_OPTION</span>
0055 <span class="comment">%       - * OBJECTS_GET</span>
0056 <span class="comment">%       - * OBJECTS_IGNORE</span>
0057 <span class="comment">%       - ** META_STRUCT</span>
0058 <span class="comment">%       - ** SUBSET_IS_LENGTH</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%   EXAMPLES:</span>
0061 <span class="comment">%   a) [~,metaStruct] = TDMS_readTDMSfile(fileName,'GET_DATA_OPTION','getnone')</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%   %some code ...</span>
0064 <span class="comment">%</span>
0065 <span class="comment">%   data = TDMS_readTDMSfile(metaStruct,'SUBSET_GET',[100 2000],...</span>
0066 <span class="comment">%                       'SUBSET_IS_LENGTH',true)</span>
0067 <span class="comment">%</span>
0068 <span class="comment">%   This reads the same amount of data from all objects with data.  The</span>
0069 <span class="comment">%   GET_DATA_OPTION has not been used to limit which objects to retrieve.</span>
0070 <span class="comment">%   The SUBSET_IS_LENGTH = true (defined below), indicates that the 2000</span>
0071 <span class="comment">%   value indicates the # of samples to read, not the stopping index.</span>
0072 <span class="comment">%</span>
0073 <span class="comment">%   3) COMPLETE SPECIFICATION OF DATA TO RETRIEVE</span>
0074 <span class="comment">%   =======================================================================</span>
0075 <span class="comment">%   This was designed to offer even more flexibility.  In this case the</span>
0076 <span class="comment">%   GET_DATA_OPTION and SUBSET_GET are IGNORED.  A new variable,</span>
0077 <span class="comment">%   GET_INDICES needs to be specified.</span>
0078 <span class="comment">%</span>
0079 <span class="comment">%   PROPERTIES:</span>
0080 <span class="comment">%       - GET_INDICES</span>
0081 <span class="comment">%       - ** META_STRUCT</span>
0082 <span class="comment">%       - ** SUBSET_IS_LENGTH</span>
0083 <span class="comment">%</span>
0084 <span class="comment">%   EXAMPLES:</span>
0085 <span class="comment">%   a) [~,metaStruct] = TDMS_readTDMSfile(fileName,'GET_DATA_OPTION','getnone')</span>
0086 <span class="comment">%</span>
0087 <span class="comment">%   %some code</span>
0088 <span class="comment">%</span>
0089 <span class="comment">%   getStruct = struct('group',myGroup,'channel',myChannel,...</span>
0090 <span class="comment">%       indices,[1 5; 10 5; 20 5; 30 5]);</span>
0091 <span class="comment">%</span>
0092 <span class="comment">%   data = TDMS_readTDMSfile(metaStruct,'GET_INDICES',getStruct);</span>
0093 <span class="comment">%</span>
0094 <span class="comment">%   SIDENOTE ON IMAGES:</span>
0095 <span class="comment">%   Since tdms does not support 2d writing, image data itself can be</span>
0096 <span class="comment">%   represented in 1d with multiple lines.  Reading multiple contiguous</span>
0097 <span class="comment">%   frames of image data would only require a single read.  If however, for</span>
0098 <span class="comment">%   each of those images, a subset of that frame is needed, then data is</span>
0099 <span class="comment">%   needed in a non-contiguous fashion. This may be acheivable via</span>
0100 <span class="comment">%   indexing in Matlab.  When memory is a concern, this might be better to</span>
0101 <span class="comment">%   do when originally reading in the data. This was the original motivation</span>
0102 <span class="comment">%   for developing this read specification.</span>
0103 <span class="comment">%</span>
0104 <span class="comment">%   =======================================================================</span>
0105 <span class="comment">%                         PROPERTIES - DEFINITIONS</span>
0106 <span class="comment">%   =======================================================================</span>
0107 <span class="comment">%   NOTE: These values get passed in as property/value pairs into the</span>
0108 <span class="comment">%   TDMS_readTDMSfile</span>
0109 <span class="comment">%</span>
0110 <span class="comment">%   GET_DATA_OPTION = (default 'getAll')</span>
0111 <span class="comment">%                       NOTE: This applies specifically to the channels and</span>
0112 <span class="comment">%                       groups, not to the data that is in those objects</span>
0113 <span class="comment">%               'getall'       - retrieve raw data from all objects</span>
0114 <span class="comment">%               'getnone'      - retrieve raw data from no objects</span>
0115 <span class="comment">%               'ignoreSubset' - requires population of OBJECTS_IGNORE</span>
0116 <span class="comment">%                                retrieves raw data for all objects except</span>
0117 <span class="comment">%                                those specified</span>
0118 <span class="comment">%               'getSubset'    - requires population of OBJECTS_GET</span>
0119 <span class="comment">%                                retrieves raw data only from objects</span>
0120 <span class="comment">%                                specified</span>
0121 <span class="comment">%</span>
0122 <span class="comment">%   OBJECTS_GET     = must be specified for GET_DATA_OPTION = 'getSubset'</span>
0123 <span class="comment">%               (structure) with fields:</span>
0124 <span class="comment">%               .fullPathsKeep - (cell array of strings) the full object</span>
0125 <span class="comment">%                                path name like /'myGroup'/'myChan' (NOTE:</span>
0126 <span class="comment">%                                the apostrophes are needed)</span>
0127 <span class="comment">%               .groupsKeep    - (cell array of strings) the name of any</span>
0128 <span class="comment">%                                 groups to keep -&gt; 'myGroup', all channels</span>
0129 <span class="comment">%                                 in that group are retrieved</span>
0130 <span class="comment">%   OBJECTS_IGNORE  = must be specified for GET_DATA_OPTION = 'ignoreSubset'</span>
0131 <span class="comment">%               (structure with fields:</span>
0132 <span class="comment">%               .fullPathsIgnore - (see above), specified paths don't</span>
0133 <span class="comment">%                                  retrieve raw data</span>
0134 <span class="comment">%               .groupsIgnore    - (see above), raw data not retrieved for</span>
0135 <span class="comment">%                                  any of the channels in the groups mentioned</span>
0136 <span class="comment">%</span>
0137 <span class="comment">%   SUBSET_GET     = (2 column array), cols =&gt;</span>
0138 <span class="comment">%                    [start sample, # of samples]</span>
0139 <span class="comment">%                               or</span>
0140 <span class="comment">%                    [start sample, stop sample]</span>
0141 <span class="comment">%                               for SUBSET_IS_LENGTH = false</span>
0142 <span class="comment">%                    The default, [], indicates to retrieve all raw data</span>
0143 <span class="comment">%                    for an object.  WARNING: Only implemented for</span>
0144 <span class="comment">%                    decimated data, not interleaved</span>
0145 <span class="comment">%</span>
0146 <span class="comment">%   SUBSET_IS_LENGTH = (default true), if true, then the 2nd input for</span>
0147 <span class="comment">%                       SUBSET_GET, and the 2nd column for the 'indices'</span>
0148 <span class="comment">%                       field in GET_INDICES, is treated as the # of</span>
0149 <span class="comment">%                       samples to read, if false, it is treated as the</span>
0150 <span class="comment">%                       stopping index</span>
0151 <span class="comment">%</span>
0152 <span class="comment">%   GET_INDICES     = (structure array), length is equal to the number</span>
0153 <span class="comment">%                      of channels to retrieve</span>
0154 <span class="comment">%               .group   - group name of object to retrieve</span>
0155 <span class="comment">%               .channel - channel name of object to retrieve</span>
0156 <span class="comment">%               .indices - (rows by 2 columns), first column indicates the</span>
0157 <span class="comment">%                          the first sample to retreive (1 based), 2nd</span>
0158 <span class="comment">%                          columns indicates either the # of samples to</span>
0159 <span class="comment">%                          retrieve (SUBSET_IS_LENGTH = true) or the last</span>
0160 <span class="comment">%                          sample to grab (SUBSET_IS_LENGTH = false)</span>
0161 <span class="comment">%                          WARNINGS:</span>
0162 <span class="comment">%                            - Only implemented for decimated data</span>
0163 <span class="comment">%                            - indices must be sorted and non-overlapping</span>
0164 <span class="comment">%                            i.e. for SUBSET_IS_LENGTH = false,</span>
0165 <span class="comment">%                               .indices = [5 10; 15 20] is fine</span>
0166 <span class="comment">%                               .indices = [5 10; 10 20] fine ...</span>
0167 <span class="comment">%                               NOTE: 10 will only be returned once</span>
0168 <span class="comment">%                               .indices = [5 10; 8 15] not ok, (overlapping)</span>
0169 <span class="comment">%                               .indices = [15 20; 5 10] not ok, (not sorted)</span>
0170 <span class="comment">%</span>
0171 <span class="comment">%   META_STRUCT     = The meta struct from a previous parsing. Passing this</span>
0172 <span class="comment">%                     in when reading the same file that generated the meta</span>
0173 <span class="comment">%                     struct previously can significantly speed up</span>
0174 <span class="comment">%                     processing time.</span>
0175 <span class="comment">%</span>
0176 <span class="comment">%</span>
0177 <span class="comment">%   See Also:</span>
0178 <span class="comment">%       TDMS_readTDMSFile</span></pre></div>
<hr><address>Generated on Sun 19-Aug-2018 19:01:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>